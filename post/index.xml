<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Technius&#39; Blog</title>
    <link>https://technius.github.io/post/index.xml</link>
    <description>Recent content in Posts on Technius&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://technius.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating a Calculator in Rust, Part 1</title>
      <link>https://technius.github.io/post/rust-calculator-1/</link>
      <pubDate>Fri, 13 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://technius.github.io/post/rust-calculator-1/</guid>
      <description>

&lt;p&gt;As an exercise to learn more about Rust, I decided to write a calculator
program. It&amp;rsquo;s able to evaluate arbitrary numerical expressions (i.e.
&lt;code&gt;2 * 3^5 / 3&lt;/code&gt;), as well as simple algebraic expressions (i.e. &lt;code&gt;3x + 5x&lt;/code&gt;). These
articles will document some of the hurdles that I ran into, as well as the
solutions that I came up with. Well, let&amp;rsquo;s not linger any longer and jump right
in!&lt;/p&gt;

&lt;h1 id=&#34;defining-the-ast&#34;&gt;Defining the AST&lt;/h1&gt;

&lt;p&gt;After creating the project files with &lt;code&gt;cargo&lt;/code&gt;, let&amp;rsquo;s start by defining the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;abstract syntax tree&lt;/a&gt; that
represents each numerical expression. An easy way to do that is to come up with
some sample expressions that we want to evaluate, such as&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 + 1 - 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 * 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5 / 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(1 + 1) * 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3x + 5x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Based on the first example, it seems like we&amp;rsquo;ll need a term to represent a
constant, as well as a term to represent a sum. Subtraction (i.e &lt;code&gt;2 - 1&lt;/code&gt;) is
special case of a sum with a negative term, so we don&amp;rsquo;t have to add a term for
it. Next, we&amp;rsquo;ll need terms for multiplication and division. We can&amp;rsquo;t just use
one term for both like we can for addition and subtraction, since it&amp;rsquo;s possible
to multiply by zero but not divide by zero. Let&amp;rsquo;s go ahead and sketch out the
initial enum:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;enum Expr {
    Const(f64),
    Sum(f64, f64),
    Product(f64, f64),
    Quotient(f64, f64)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a problem with this representation, though; we can&amp;rsquo;t express chained
operations like &lt;code&gt;1 + 1 * 2&lt;/code&gt;. We&amp;rsquo;ll have to modify the enum to hold Expr instead.
The simplest approach may be to replace the &lt;code&gt;f64&lt;/code&gt;s in &lt;code&gt;Sum&lt;/code&gt;, &lt;code&gt;Product&lt;/code&gt;, and
&lt;code&gt;Quotient&lt;/code&gt; with &lt;code&gt;Expr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;enum Expr {
    Const(f64),
    Sum(Expr, Expr),
    Product(Expr, Expr),
    Quotient(Expr, Expr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, this fails to compile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error[E0072]: recursive type `Expr` has infinite size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Sum&lt;/code&gt; could contain infinitely many &lt;code&gt;Sum&lt;/code&gt;s, for example, so it would be
impossible for Rust to determine how large an Expr would be. Instead, we&amp;rsquo;ll have
to use references inside of each recursive term. We could write &lt;code&gt;&amp;amp;Expr&lt;/code&gt;, but then
we&amp;rsquo;d have to manage a lot of lifetimes. Instead, let&amp;rsquo;s use &lt;code&gt;Box&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;enum Expr {
    Const(f64),
    Sum(Box&amp;lt;Expr&amp;gt;, Box&amp;lt;Expr&amp;gt;),
    Product(Box&amp;lt;Expr&amp;gt;, Box&amp;lt;Expr&amp;gt;),
    Quotient(Box&amp;lt;Expr&amp;gt;, Box&amp;lt;Expr&amp;gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great, it compiles! Let&amp;rsquo;s try it out by writing out &lt;code&gt;1 + 1&lt;/code&gt; and &lt;code&gt;1 + 1 * 2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let one_plus_one =
    Expr::Sum(
        Box::new(Expr::Const(1.0)),
	Box::new(Expr::Const(1.0))
    );

let one_plus_one_times_two = 
    Expr::Sum(
        Box::new(Expr::Const(1.0)),
	Box::new(
	    Expr::Product(
	        Box::new(Expr::Const(1.0)),
	        Box::new(Expr::Const(2.0))
	    )
	)
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, it requires a lot of boilerplate, but it works. After adding &lt;code&gt;#[derive(Debug)]&lt;/code&gt; above
the &lt;code&gt;Expr&lt;/code&gt; enum, we can print out an &lt;code&gt;Expr&lt;/code&gt; e.g.
&lt;code&gt;println!(&amp;quot;{:?}&amp;quot;, one_plus_one)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;implementing-a-dsl&#34;&gt;Implementing a DSL&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;d be nice if we could write out calculations directly in our code. That&amp;rsquo;s
sounds like a good case for writing a macro, but let&amp;rsquo;s try something simpler
instead: making a DSL. The greatest inconvenience is probably the fact that we
have to box each term in a sum or product. Let&amp;rsquo;s write a few helper functions to
automatically do the boxing for us. Implementation should be very
straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl Expr { // In this section, we&#39;ll just focus on sum and product
    fn sum(lh: Expr, rh: Expr) -&amp;gt; Expr {
        Expr::Sum(Box::new(lh), Box::new(rh))
    }

    fn product(lh: Expr, rh: Expr) -&amp;gt; Expr {
        Expr::Product(Box::new(lh), Box::new(rh))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, instead of writing &lt;code&gt;Expr::Sum(Box::new(...), Box::new(...))&lt;/code&gt;, we could just
write &lt;code&gt;Expr::product(Expr::Const(1), Expr::Const(2))&lt;/code&gt;. This is already much
better, but let&amp;rsquo;s take it a step further: let&amp;rsquo;s aim for something like
&lt;code&gt;Expr::sum(1, Expr::product(1, 2))&lt;/code&gt;. We don&amp;rsquo;t want to just limit our parameters
to &lt;code&gt;Expr&lt;/code&gt;, but we also want to include &lt;code&gt;f64&lt;/code&gt;. We can achieve that by using a
type parameter with a trait bound on it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn sum&amp;lt;L, R&amp;gt;(lh: L, rh: R) -&amp;gt; Expr where L: Into&amp;lt;Expr&amp;gt;, R: Into&amp;lt;Expr&amp;gt; {
    Expr::Sum(Box::new(lh.into()), Box::new(rh.into()))
}

fn product&amp;lt;L, R&amp;gt;(lh: L, rh: R) -&amp;gt; Expr where L: Into&amp;lt;Expr&amp;gt;, R: Into&amp;lt;Expr&amp;gt; {
    Expr::Product(Box::new(lh.into()), Box::new(rh.into()))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://doc.rust-lang.org/std/convert/trait.Into.html&#34;&gt;&lt;code&gt;Into&lt;/code&gt; trait&lt;/a&gt;
lets us use a type &lt;code&gt;T&lt;/code&gt; as a parameter given that we implement an &lt;code&gt;into&lt;/code&gt; function
which converts from a &lt;code&gt;T&lt;/code&gt; to the target type (which, in our case, is &lt;code&gt;Expr&lt;/code&gt;). In
the case of the above function, we&amp;rsquo;ll use &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; instead of a single &lt;code&gt;T&lt;/code&gt;,
since the left and right hand parameters could have different types, like in
&lt;code&gt;Expr::sum(1, Expr::sum(1, 2))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Speaking of which, we can&amp;rsquo;t write an expression using &lt;code&gt;f64&lt;/code&gt; directly without
implementing &lt;code&gt;Into&amp;lt;Expr&amp;gt;&lt;/code&gt; for &lt;code&gt;f64&lt;/code&gt;. However, it seems more natural to
implement a &lt;code&gt;From&amp;lt;f64&amp;gt;&lt;/code&gt; for &lt;code&gt;Expr&lt;/code&gt; (&lt;a href=&#34;https://doc.rust-lang.org/std/convert/trait.From.html#generic-impls&#34;&gt;which provides an &lt;code&gt;Into&lt;/code&gt; instance for free&lt;/a&gt;) instead,
since we want to convert &lt;em&gt;from&lt;/em&gt; an &lt;code&gt;f64&lt;/code&gt; to an &lt;code&gt;Expr&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl From&amp;lt;f64&amp;gt; for Expr {
    fn from(x: f64) -&amp;gt; Expr {
        Expr::Const(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now write out &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt; with a mix of &lt;code&gt;f64&lt;/code&gt; and &lt;code&gt;Expr&lt;/code&gt;. Let&amp;rsquo;s
rewrite &lt;code&gt;one_plus_one&lt;/code&gt; and &lt;code&gt;one_plus_one_times_two&lt;/code&gt; and add an even more
complicated expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let one_plus_one = Expr::sum(1.0, Expr::Const(1.0));
let one_plus_one_times_two = Expr::sum(1.0, Expr::product(1.0, 2.0));

let complicated_expr =
    Expr::sum(Expr::product(1.0, 2.0), Expr::product(3.0, 4.0));
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bonus-natural-looking-expressions&#34;&gt;Bonus: Natural-looking Expressions&lt;/h1&gt;

&lt;p&gt;Going even further, we could make it possible to use the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;
operators in our code. All we have to do is implement the &lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Sub&lt;/code&gt;, &lt;code&gt;Mul&lt;/code&gt;,
and &lt;code&gt;Div&lt;/code&gt; traits, respectively, by specifying the resulting type (which, in our
case, is &lt;code&gt;Expr&lt;/code&gt;) and implementing a function corresponding to the operation. All
we have to do is call the functions that we&amp;rsquo;ve already written. The impl for
&lt;code&gt;Add&lt;/code&gt; is shown below; the others are similar.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::ops::{Add, Sub, Mul, Div};
impl Add for Expr {
    type Output = Expr;
    fn add(self, other: Expr) -&amp;gt; Expr {
        Expr::sum(self, other)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can simplify &lt;code&gt;complicated_expr&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Expr::product(1.0, 2.0) + Expr::product(3.0, 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can&amp;rsquo;t just write &lt;code&gt;1.0 * 2.0 + 3.0 * 4.0&lt;/code&gt;, since Rust will simply evaluate
that to a &lt;code&gt;f64&lt;/code&gt;. In any case, additional simplication won&amp;rsquo;t really help
readability, so let&amp;rsquo;s stop here (we could always try to write a macro, though.
Maybe next time).&lt;/p&gt;

&lt;h1 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s Next&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve shown how to compose an AST for a calculator in Rust. I didn&amp;rsquo;t implement
the DSL for &lt;code&gt;Quotient&lt;/code&gt;, but it should be similar to implementing &lt;code&gt;Add&lt;/code&gt; and
&lt;code&gt;Product&lt;/code&gt;. Of course, simply defining our data structure isn&amp;rsquo;t very
interesting&amp;mdash;we want to be able to do something with it! In the next post in
the series, I&amp;rsquo;ll explore how to evaluate our expressions and turn the calculator
into an &lt;em&gt;actual&lt;/em&gt; calculator.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello world!</title>
      <link>https://technius.github.io/post/hello/</link>
      <pubDate>Thu, 15 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://technius.github.io/post/hello/</guid>
      <description>&lt;p&gt;&lt;em&gt;Obligatory hello world post.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m setting up a blog again , but this time, I&amp;rsquo;m planning on actually posting
stuff! This time, the goal is to improve my writing skills; though my grammar is
quite good, I&amp;rsquo;m terrible at writing anything other than directions, code, or
technical explanations (though I&amp;rsquo;ll &lt;em&gt;probably&lt;/em&gt; end up spending most of my time
on these types of writing). In particular, I have a &lt;em&gt;really&lt;/em&gt; hard time putting
essays together. I&amp;rsquo;m going to use this blog to practice.&lt;/p&gt;

&lt;p&gt;Currently, I&amp;rsquo;m trying to figure out a nice, declarative, type-safe way to write
a game engine in Scala. There&amp;rsquo;s a lot of interesting ways to approach it, but
I&amp;rsquo;ve settled on a hybrid mutable/immutable approach: the mutable part is just to
avoid allocations that&amp;rsquo;ll clog up the garbage collector, and the immutable part
will make automated testing feasible. I&amp;rsquo;ve been intermittently working on this
idea for almost a year now, so I&amp;rsquo;m really looking forward to seeing what I&amp;rsquo;ll
end up with.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m also trying to learn Rust. Seriously, Rust is a really cool language.  It&amp;rsquo;s
fast (as in runtime), has a strong type system, and includes a lot of convenient
features like pattern matching and typeclasses. I&amp;rsquo;ll be uploading a little
calculator program written in Rust in a short while; feel free to check it out!&lt;/p&gt;

&lt;p&gt;In any case, stay tuned for more! I&amp;rsquo;ll try to publish at least once-a-month, but
I can&amp;rsquo;t make any guarantees.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>