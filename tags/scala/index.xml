<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on Bryan Tan&#39;s Blog</title>
    <link>https://technius.github.io/tags/scala/index.xml</link>
    <description>Recent content in Scala on Bryan Tan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2016-2017 Bryan Tan. Articles are licensed under CC-BY-4.0; code in articles licensed under MIT License.</copyright>
    <atom:link href="https://technius.github.io/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Cleaner Error Handling in Scala with Cats EitherT</title>
      <link>https://technius.github.io/post/eithert-error-handling/</link>
      <pubDate>Tue, 09 May 2017 22:04:06 -0700</pubDate>
      
      <guid>https://technius.github.io/post/eithert-error-handling/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In Scala, it&amp;rsquo;s a common practice to handle errors or perform validation using
&lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt;. For example, a form on a website may be validated on a
server by using a series of &lt;code&gt;Either&lt;/code&gt;s, which will return the valid model data or
a message explaining the problems in the form submission. However, adding
more complicated concerns into the &lt;code&gt;Either&lt;/code&gt; sequence, such as &lt;code&gt;Option&lt;/code&gt;s or
&lt;code&gt;Future&lt;/code&gt;s, requires a lot of boilerplate.&lt;/p&gt;

&lt;p&gt;To see how this might happen, let&amp;rsquo;s consider a simple example, account
registration. In our case, an account consists of a username, a password and an
email address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Account(username: String, password: String, email: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To register for an account, a new user has to provide all three of these fields,
which usually follow a set of restrictions. For example, most websites require
passwords to have a minimum length, and some websites don&amp;rsquo;t allow usernames to
have spaces. The user registration form might be validated like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Note: This example requires Scala 2.12, which allows Either to be used
// in for comprehensions

import scala.util.{ Either, Left, Right }

type ErrorOr[A] = Either[String, A]

def validateUsername(username: String): ErrorOr[String] = ???
def validatePassword(password: String): ErrorOr[String] = ???
def validateEmail(email: String): ErrorOr[String] = ???

def validateAccount(usernameInput: String, passwordInput: String, emailInput: String): ErrorOr[Account] =
  for {
    username &amp;lt;- validateUsername(usernameInput)
    password &amp;lt;- validatePassword(passwordInput)
    email &amp;lt;- validateEmail(emailInput)
  } yield Account(usernameInput, passwordInput, email)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks clean, but creating the actual account isn&amp;rsquo;t. For example, user
registration might involve checking for existing accounts, saving the account a
database, and sending a welcome email. In addition, the aforementioned actions
may need to occur asynchronously, which means that we have to handle &lt;code&gt;Future&lt;/code&gt;s,
as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findAccountWithEmail(email: String): Future[Option[Account]] = ???
def sendWelcomeEmail(email: String): Future[Unit] = ???
def insertAccountIntoDatabase(newAccount: Account): Future[Account] = ???

def registerAccount(usernameInput: String, passwordInput: String, emailInput: String): Future[ErrorOr[Account]] = {
  validateAccount(usernameInput, passwordInput, emailInput).fold(
    error =&amp;gt; Future.successful(Left(error)),
    validAccount =&amp;gt; findAccountWithEmail(emailInput) flatMap {
      case Some(_) =&amp;gt;
        val errorMessage = &amp;quot;Account with this email already exists!&amp;quot;
        Future.successful(Left(errorMessage))
      case None =&amp;gt;
        for {
          _ &amp;lt;- insertAccountIntoDatabase(validAccount)
          _ &amp;lt;- sendWelcomeEmail(validAccount.email)
        } yield Right(validAccount)
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a lot of noise that distracts from how the process works. Also, it&amp;rsquo;s a
pain to write the boilerplate, especially since form validation is quite common.&lt;/p&gt;

&lt;p&gt;The problem is that the steps don&amp;rsquo;t compose very well. It would be far nicer if
we could just write a single for-comprehension that deals strictly with &lt;code&gt;Either&lt;/code&gt;
and let some other underlying mechanism handle the &lt;code&gt;Future&lt;/code&gt; boilerplate. For
example, a clean hypothetical example of a &lt;code&gt;registerAccount&lt;/code&gt; function would be&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def registerAccount(usernameInput: String, passwordInput: String, emailInput: String): Future[ErrorOr[Account]] =
  for {
    validAccount &amp;lt;- validateAccount(usernameInput, passwordInput, emailInput)
    accountOpt &amp;lt;- findAccount(validAccount.email) if accountOpt.isEmpty
    _ &amp;lt;- insertAccountIntoDatabase(validAccount)
    _ &amp;lt;- sendWelcomeEmail(validAccount.email)
  } yield validAccount
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;abstracting-away-either-handling&#34;&gt;Abstracting Away Either Handling&lt;/h1&gt;

&lt;p&gt;We can get pretty close to that hypothetical example by using the &lt;code&gt;EitherT&lt;/code&gt;
monad transformer. It&amp;rsquo;s not necessary to know what a &amp;ldquo;monad transformer&amp;rdquo; is,
only that &lt;code&gt;EitherT&lt;/code&gt; is a wrapper for some effectful type (e.g. &lt;code&gt;Option&lt;/code&gt; or
&lt;code&gt;Future&lt;/code&gt;) that can abstract away the effect and handle the contents of the type
in a more convenient manner. I&amp;rsquo;m going to use the &lt;code&gt;EitherT&lt;/code&gt; from cats, but the
&lt;code&gt;EitherT&lt;/code&gt; from scalaz should also work (albeit with different function names).&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;EitherT&lt;/code&gt; is pretty straightforward: wrap your desired data in &lt;code&gt;EitherT&lt;/code&gt;,
compose the &lt;code&gt;EitherT&lt;/code&gt; values using a for-comprehension, and then extract the
final wrapped &lt;code&gt;F[Either[B, A]]&lt;/code&gt; using the &lt;code&gt;value&lt;/code&gt; method, where &lt;code&gt;F&lt;/code&gt; is the
effectful type, &lt;code&gt;B&lt;/code&gt; is the error type, and &lt;code&gt;A&lt;/code&gt; is the type of the valid data.
Here&amp;rsquo;s an example using &lt;code&gt;Future&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type Result[A] = EitherT[Future, String, A] // wraps a Future[Either[String, A]]

val numberET: Result[Int] = EitherT.pure(5) // pure has type A  =&amp;gt; EitherT[F, B, A]
val numberOpt = Some(10)

val finalEitherT = for {
  n &amp;lt;- numberET
  // fromOption transforms an Option into an Right if it exists, or a Left with
  // erroraneous value otherwise.
  numberOpt &amp;lt;- EitherT.fromOption(numberOpt, &amp;quot;Number not defined&amp;quot;)
} yield (n + numberOpt)

val myFuture: Future[Either[String, Int]] = finalEitherT.value // convert EitherT to Future

val lifted: Result[Int] = EitherT.fromEither(Right(5)) // convert Either to EitherT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Failures work as expected, conforming to the short-circuiting nature of &lt;code&gt;Either&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val successful: Result[Int] = EitherT.pure(5)
val fail: Result[Int] = EitherT.fromEither(Left(&amp;quot;Nope&amp;quot;))
val neverReached: Result[Int] = EitherT.pure(5)

val myEitherT: Result[Int] = for {
  a &amp;lt;- successful
  b &amp;lt;- fail
  c &amp;lt;- neverReached
} yield c

println(myEitherT.value) // Nope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try out the &lt;code&gt;EitherT&lt;/code&gt; functions with different values and combinations, and see
what you get!&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also a convenient function called &lt;code&gt;cond&lt;/code&gt;, which is similar to an
if-statement for &lt;code&gt;EitherT&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def asyncDivide(n: Int, divisor: Int): Result[Int] =
  EitherT.cond(divisor != 0, n / divisor, &amp;quot;Cannot divide by zero&amp;quot;)

asyncDivide(5, 0) // Cannot divide by zero
asyncDivide(10, 2) // Successful
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;reimplementing-registeraccount&#34;&gt;Reimplementing &lt;code&gt;registerAccount&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Now that we&amp;rsquo;re armed with &lt;code&gt;EitherT&lt;/code&gt;, let&amp;rsquo;s reimplement &lt;code&gt;registerAccount&lt;/code&gt; in a
more elegant way. The goal is to make the logic more explicit by ordering each
step sequentially. First, let&amp;rsquo;s bring back the handy &lt;code&gt;Result&lt;/code&gt; alias:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type Result[A] = EitherT[Future, String, A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;rsquo;s refactor the &lt;code&gt;validateAccount&lt;/code&gt; logic. Since &lt;code&gt;Either&lt;/code&gt; is already
returned for each step, all we have to do is lift each &lt;code&gt;Either&lt;/code&gt; with
&lt;code&gt;EitherT.fromEither&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def validateAccount(usernameInput: String, passwordInput: String, emailInput: String): Result[Account] =
  for {
    username &amp;lt;- EitherT.fromEither(validateUsername(usernameInput))
    password &amp;lt;- EitherT.fromEither(validatePassword(passwordInput))
    email &amp;lt;- EitherT.fromEither(validateEmail(emailInput))
  } yield Account(usernameInput, passwordInput, email)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problematic part is testing for the existing account, since it causes the
logic to branch off:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findAccountWithEmail(email: String): Future[Option[Account]] = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the account can&amp;rsquo;t be found, it should return an error message and stop the
registration immediately. Otherwise, it should continue with registration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def testForExistingAccount(email: String): Result[Unit] =
    EitherT(findAccountWithEmail(email) map {
      case Some(_) =&amp;gt; Left(&amp;quot;An account with this email already exists&amp;quot;)
      case None =&amp;gt; Right(())
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, all that remains is to compose the steps in the &lt;code&gt;registerAccount&lt;/code&gt; function.
This should be trivial, since the types that we&amp;rsquo;re dealing with are &lt;code&gt;Future&lt;/code&gt;,
&lt;code&gt;Either&lt;/code&gt;, and &lt;code&gt;EitherT&lt;/code&gt;, which can all be combined into &lt;code&gt;EitherT&lt;/code&gt; in a single
for-comprehension.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def registerAccount(usernameInput: String, passwordInput: String, emailInput: String): Future[ErrorOr[Account]] = {
  val eitherT: Result[Account] = for {
    newAccount &amp;lt;- validateAccount(usernameInput, passwordInput, emailInput)
    _ &amp;lt;- testForExistingAccount(emailInput)
    _ &amp;lt;- EitherT(insertAccountIntoDatabase(newAccount))
    _ &amp;lt;- EitherT(sendWelcomeEmail(newAccount.email))
  } yield newAccount

  eitherT.value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty close to the ideal code, and it&amp;rsquo;s very easy to understand!&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve shown that using &lt;code&gt;EitherT&lt;/code&gt; can make error handling far more readable. Like
I briefly mentioned above, &lt;code&gt;EitherT&lt;/code&gt; works for effectful types such as
&lt;code&gt;Option[Either[String, Int]]&lt;/code&gt; or &lt;code&gt;IO[Either[String, Int]]&lt;/code&gt;. Since these types
are so generally, it&amp;rsquo;s easy to see that &lt;code&gt;EitherT&lt;/code&gt; has a large variety of use
cases, especially for short-circuiting steps.&lt;/p&gt;

&lt;p&gt;Sometimes, it might be desirable to use &lt;code&gt;EitherT&lt;/code&gt; in situations involving
parallel validation (e.g. validate all fields at the same time and return a list
of all errors). In that case, with some effort, &lt;code&gt;Validated&lt;/code&gt; (or &lt;code&gt;Validation&lt;/code&gt;)
can be used with &lt;code&gt;EitherT&lt;/code&gt; to add parallel validation. Use &lt;code&gt;Either&lt;/code&gt; for
sequential validation and &lt;code&gt;Validated&lt;/code&gt; for parallel validation for the best
effects! See the &lt;a href=&#34;http://typelevel.org/cats/datatypes/either.html&#34;&gt;&lt;code&gt;Either&lt;/code&gt;&lt;/a&gt;
and &lt;a href=&#34;http://typelevel.org/cats/datatypes/validated.html&#34;&gt;&lt;code&gt;Validation&lt;/code&gt;&lt;/a&gt; documentation for more information.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Improving Akka HTTP REST API Response Handling with Marshallers</title>
      <link>https://technius.github.io/post/akka-http-api-response-marshalling/</link>
      <pubDate>Fri, 24 Mar 2017 23:54:00 -0700</pubDate>
      
      <guid>https://technius.github.io/post/akka-http-api-response-marshalling/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been trying out &lt;a href=&#34;http://doc.akka.io/docs/akka-http/current/scala/http/introduction.html&#34;&gt;akka-http&lt;/a&gt; for a while now, and I found it to
be great for making REST APIs. However, it is complicated to use and can lead to
a massive amount of boilerplate if its features aren&amp;rsquo;t taken advantage of
completely. In this article, I&amp;rsquo;m going to to take a look at one feature of Akka
HTTP that I explored recently: marshallers.&lt;/p&gt;

&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;To demonstrate how status codes are usually returned in Akka HTTP, let&amp;rsquo;s
consider a simple example of a REST API: an online notepad. Each note should
have a title and content. The API should have basic CRUD endpoints:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET /notes&lt;/code&gt; retrieves all notes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST /notes?title=Foo&amp;amp;content=bar&lt;/code&gt; creates a new note titled &amp;ldquo;&amp;rdquo;, storing
&amp;ldquo;bar&amp;rdquo; as its content. The status code is &lt;code&gt;201 Created&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET /notes/123&lt;/code&gt; retrieves the note with id 123, if it exists.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST /notes/123?title=Foo2&amp;amp;content=bar2&lt;/code&gt; updates the note with id 123, if
it exists. If neither title nor content are supplied, return
&lt;code&gt;304 Not Modified&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE /notes/123&lt;/code&gt; deletes the note with id 123, if it exists.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s begin by modeling each note:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Note(id: Int, title: String, content: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, let&amp;rsquo;s define an interface which will handle how the &lt;code&gt;Notes&lt;/code&gt; are stored:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait NoteRepository {
  def list(): Future[Seq[Note]]
  def find(id: Int): Future[Option[Note]]
  def create(title: String, content: String): Future[Note]
  def update(id: Int, title: Option[String], content: Option[String]): Future[Option[Note]]
  def delete(id: Int): Future[Option[Note]]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we move on to writing the routes, let&amp;rsquo;s write an intermediate layer that
will help translate the results into a standard, easy-to-serialize format. In
most cases, that format would be an algebraic data type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/* Represents the response to an API call */
sealed trait ApiResult
object ApiResult {
  /* Returns notes found */
  case class FoundNote(note: Note) extends ApiResult
  
  /* Indicates when a specified note cannot be found */
  case class NoteNotFound(id: Int) extends ApiResult
  
  /* Indicates when a note is successfully created */
  case class CreatedNote(note: Note) extends ApiResult
 
  /* Indicates when a note is successfully updated */
  case class UpdatedNote(updatedNote: Note) extends ApiResult
 
  /* Indicates when a note is sucessfully deleted. */
  case class DeletedNote(deletedNote: Note) extends ApiResult
}

trait NoteService {
  import ApiResult._

  def repo: NoteRepository

  def find(id: Int): Future[ApiResult] =
    repo.find(id).map(noteOp(id)(FoundNote.apply _))

  def create(title: String, content: String): Future[ApiResult] =
    repo.create(title, content).map(CreatedNote.apply _)

  def update(id: Int, title: Option[String], content: Option[String]): Future[ApiResult] =
    repo.update(id, title, content).map(noteOp(id)(UpdatedNote.apply _))

  def delete(id: Int): Future[ApiResult] =
    repo.delete(id).map(noteOp(id)(DeletedNote.apply _))

  /*
   * Helper for returning NoteNotFound if an Option is None, or passing the
   * found note to f otherwise.
   */
  private def noteOp[T](id: Int)(f: Note =&amp;gt; ApiResult): Option[Note] =&amp;gt; ApiResult =
    opt =&amp;gt; opt.map(f).getOrElse(NoteNotFound(id))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we can define our routes. The most straightforward approach is to call
a serialization function wherever &lt;code&gt;ApiResult&lt;/code&gt; is returned. For simplicity, I
used the excellent &lt;a href=&#34;http://www.lihaoyi.com/upickle-pprint/upickle/&#34;&gt;upickle&lt;/a&gt;
library to serialize each &lt;code&gt;ApiResult&lt;/code&gt; as JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import akka.http.scaladsl.server._
import akka.http.scaladsl.server.Directives._
import upickle.default._
trait Routes {
  def noteService: NoteService
  
  val notesRoute =
    pathPrefix(&amp;quot;notes&amp;quot;) {
      // -&amp;gt; /notes/id
      (path(IntNumber)) { id =&amp;gt;
        get {
          complete {
            noteService.find(id).map(write(_))
          }
        } ~
        delete {
          complete {
            noteService.delete(id).map(write(_))
          }
        } ~
        (post &amp;amp; parameters(&#39;title.?, &#39;content.?)) { (title, content) =&amp;gt;
          complete {
            noteService.update(id, title, content).map(write(_))
          }
        }
      } ~
      // -&amp;gt; /notes
      pathEndOrSingleSlash {
        get {
          complete {
            noteService.list.map(write(_))
          }
        } ~
        (post &amp;amp; parameters(&#39;title, &#39;content)) { (title, content) =&amp;gt;
          complete {
            noteService.create(title, content).map(write(_))
          }
        }
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To try it out, you&amp;rsquo;ll need an implementation of &lt;code&gt;NoteRepository&lt;/code&gt;. I&amp;rsquo;ve written a
complete, naive example in this &lt;a href=&#34;https://gist.github.com/Technius/4fddfc9e33b6c2fff13cbea5e4c67d53&#34;&gt;gist&lt;/a&gt; (Warning: do &lt;em&gt;not&lt;/em&gt; use this
code in production!). If we run a few queries on the server, we&amp;rsquo;ll get the
expected results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl &#39;http://localhost:1234/notes&#39; -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.ListNotes&amp;quot;,&amp;quot;notes&amp;quot;:[]}

$ curl &#39;http://localhost:1234/notes?title=test&amp;amp;content=Hi&#39; -XPOST -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.CreatedNote&amp;quot;,&amp;quot;note&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;title&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Hi&amp;quot;}}

$ curl &#39;http://localhost:1234/notes/1&#39; -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.FoundNote&amp;quot;,&amp;quot;note&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;title&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Hi&amp;quot;}}

$ curl &#39;http://localhost:1234/notes/1?title=Test&amp;amp;content=Hello&#39; -XPOST -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.UpdatedNote&amp;quot;,&amp;quot;updatedNote&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;title&amp;quot;:&amp;quot;Test&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Hello&amp;quot;}}

$ curl &#39;http://localhost:1234/notes?title=Post2&amp;amp;content=Content&#39; -XPOST -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.CreatedNote&amp;quot;,&amp;quot;note&amp;quot;:{&amp;quot;id&amp;quot;:2,&amp;quot;title&amp;quot;:&amp;quot;Post2&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Content&amp;quot;}}

$ curl &#39;http://localhost:1234/notes&#39; -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.ListNotes&amp;quot;,&amp;quot;notes&amp;quot;:[{&amp;quot;id&amp;quot;:1,&amp;quot;title&amp;quot;:&amp;quot;Test&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Hello&amp;quot;},{&amp;quot;id&amp;quot;:2,&amp;quot;title
&amp;quot;:&amp;quot;Post2&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Content&amp;quot;}]}

$ curl &#39;http://localhost:1234/notes/1&#39; -XDELETE -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.DeletedNote&amp;quot;,&amp;quot;deletedNote&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;title&amp;quot;:&amp;quot;Test&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Hello&amp;quot;}}

$ curl &#39;http://localhost:1234/notes&#39; -w &#39;\n\n&#39;
{&amp;quot;$type&amp;quot;:&amp;quot;example.ApiResult.ListNotes&amp;quot;,&amp;quot;notes&amp;quot;:[{&amp;quot;id&amp;quot;:2,&amp;quot;title&amp;quot;:&amp;quot;Post2&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;Content&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if you took a close look at the code, you&amp;rsquo;ll notice multiple problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I didn&amp;rsquo;t implement status codes because it wouldn&amp;rsquo;t be very easy to. For
example, if I wanted to add status codes on the &lt;code&gt;GET&lt;/code&gt; route, I&amp;rsquo;d have to pattern
match on the &lt;code&gt;ApiResult&lt;/code&gt; inside of the &lt;code&gt;Future&lt;/code&gt; and select the correct status
code.&lt;/li&gt;
&lt;li&gt;The content type isn&amp;rsquo;t &lt;code&gt;application/json&lt;/code&gt;. It&amp;rsquo;s just plain text (test it in your
browser!&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s tedious and boring to extend. For example, if I wanted to add status codes
for all routes, I&amp;rsquo;d have to pattern match in each route!&lt;/li&gt;
&lt;li&gt;It will be easy to introduce bugs: during a refactor, someone could
accidentally cause a &lt;code&gt;Created&lt;/code&gt; status code to be returned along with an
&lt;code&gt;ApiResult.DeletedNote&lt;/code&gt;!&lt;/li&gt;
&lt;li&gt;We have to call &lt;code&gt;write&lt;/code&gt; on each route. This code duplication is a clear sign
that we can increase abstraction.&lt;/li&gt;
&lt;li&gt;It involves far too much boilerplate for such a simple API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;building-marshallers&#34;&gt;Building marshallers&lt;/h2&gt;

&lt;p&gt;A core part of Akka HTTP is its &lt;a href=&#34;http://doc.akka.io/docs/akka-http/current/scala/http/common/marshalling.html&#34;&gt;marshalling API&lt;/a&gt;. Marshallers
describe how data is transformed, such as when an incoming HTTP request is
deserialized into, say, an int, or when an entity model is serialized into an
HTTP response. They are automatically resolved through implicit scoping and help
convert data returned in &lt;code&gt;complete&lt;/code&gt; directives into HTTP responses. This is
perfect for the above situation: a marshaller can be used not only ensure the
proper status code and content type is returned, but it can also be used to
handle serialization, and thus, remove boilerplate.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the type signature of &lt;code&gt;Marshaller&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// From the ScalaDoc
sealed abstract class Marshaller[-A, +B] extends AnyRef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Marshaller[A, B]&lt;/code&gt; serializes &lt;code&gt;A&lt;/code&gt; into &lt;code&gt;B&lt;/code&gt;. The docs recommend composing new
marshallers using existing ones, an approach we&amp;rsquo;ll take to create a marshaller
for &lt;code&gt;ApiResult&lt;/code&gt;. &lt;code&gt;Marshaller&lt;/code&gt; provides methods such as &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;compose&lt;/code&gt;,
which can transform the output or the input, respectively. We&amp;rsquo;re going to focus
on the &lt;code&gt;compose&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// From the ScalaDoc
// Given a Marshaller[A, B]:
def compose[C](f: (C) ⇒ A): Marshaller[C, B] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the types, if &lt;code&gt;compose&lt;/code&gt; is called on a &lt;code&gt;Marshaller[A, B]&lt;/code&gt; with a
function that converts &lt;code&gt;C&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, then the result is a &lt;code&gt;Marshaller[C, B]&lt;/code&gt;. In
other words, &lt;code&gt;compose&lt;/code&gt; creates a new marshaller that accepts &lt;code&gt;C&lt;/code&gt;, transforms it
to &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;f&lt;/code&gt;, and then passes it to the original marshaller &lt;code&gt;m&lt;/code&gt;, which then
converts &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We should be able to serialize an &lt;code&gt;ApiResult&lt;/code&gt; with &lt;code&gt;compose&lt;/code&gt;. If you read the
documentation, you&amp;rsquo;ll see that a &lt;code&gt;ToEntityMarshaller[A]&lt;/code&gt;, which is a
&lt;code&gt;Marshaller[A,MessageEntity]&lt;/code&gt;, is used to generate the body of an HTTP request.
That means that we want a call &lt;code&gt;compose&lt;/code&gt; on some marshaller to get a
&lt;code&gt;ToEntityMarshaller[ApiResult]&lt;/code&gt;. In the earlier code, &lt;code&gt;ApiResult&lt;/code&gt; was serialized
into a &lt;code&gt;String&lt;/code&gt; using &lt;code&gt;write[ApiResult]&lt;/code&gt;. This gives us a clue: if we convert
&lt;code&gt;ApiResult&lt;/code&gt; into a &lt;code&gt;String&lt;/code&gt; first, we&amp;rsquo;ll have our marshaller. Conveniently, Akka
HTTP provides &lt;code&gt;Marshaller.StringMarshaller&lt;/code&gt;, so we&amp;rsquo;ll just call the &lt;code&gt;compose&lt;/code&gt;
method on it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import akka.http.scaladsl.model._
import akka.http.scaladsl.marshalling._
/**
  * Mix in to provide marshalling capabilities for `ApiResult`.
  */
trait ApiMarshalling {
  /* 
   * Marshaller that serializes an ApiResult into JSON and ensures that it has
   * a content type of application/json
   */
  def apiResultTEM: ToEntityMarshaller[ApiResult] =
    Marshaller.StringMarshaller.compose(r =&amp;gt; write[ApiResult](r))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though this marshaller works, we could improve it by also specifying the content
typ, since the marshaller is used to create the message body. The &lt;code&gt;wrap&lt;/code&gt; method,
which is basically the same thing as &lt;code&gt;compose&lt;/code&gt; with an additional content type
parameter, allows us to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// From the ScalaDoc
// Given a Marshaller[A, B]:
def wrap[C, D &amp;gt;: B](newMediaType: MediaType)(f: (C) ⇒ A)(implicit mto: ContentTypeOverrider[D]): Marshaller[C, D]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;wrap&lt;/code&gt; instead of &lt;code&gt;compose&lt;/code&gt; is a simple change away:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def apiResultTEM: ToEntityMarshaller[ApiResult] =
  Marshaller.StringMarshaller.wrap(MediaTypes.`application/json`)(r =&amp;gt; write[ApiResult](r))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could make &lt;code&gt;apiResponseTEM&lt;/code&gt; implicit, but we&amp;rsquo;re not done yet: we still need
to ensure the proper status code is returned. To do so, we need to write a
&lt;code&gt;ToResponseMarshaller[ApiResult]&lt;/code&gt;, which is a
&lt;code&gt;Marshaller[ApiResult,HttpResponse]&lt;/code&gt;. The approach is the same: find an existing
marshaller and use one of its composition methods. First, we need to figure out
which status code should be returned given an &lt;code&gt;ApiResult&lt;/code&gt;, so let&amp;rsquo;s write a
helper method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ApiResult._
def getResponseCode(result: ApiResult): StatusCode = result match {
  case _: ListNotes =&amp;gt; StatusCodes.OK
  case _: FoundNote =&amp;gt; StatusCodes.OK
  case _: NoteNotFound =&amp;gt; StatusCodes.NotFound
  case _: CreatedNote =&amp;gt; StatusCodes.Created
  // To return a 304 Not Modified, UpdatedNote and the associated logic needs to
  // be changed so that it can capture the possibility that no changes were made.
  // Try it as an exercise!
  case _: UpdatedNote =&amp;gt; StatusCodes.OK
  case _: DeletedNote =&amp;gt; StatusCodes.OK
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we use another predefined marshaller to construct the
&lt;code&gt;ToResponseMarshaller[ApiResult]&lt;/code&gt; that will convert each &lt;code&gt;ApiResult&lt;/code&gt; into a
&lt;code&gt;Response&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/*
 * Marshaller that converts an ApiResult into an HttpResponse
 */
implicit def apiResultTRM: ToResponseMarshaller[ApiResult] =
    Marshaller
      .fromStatusCodeAndHeadersAndValue(apiResultTEM)
      .compose(apiResult =&amp;gt; (getResponseCode(apiResult), List.empty, apiResult))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Marshaller.fromStatusCodeAndHeadersAndValue&lt;/code&gt; used above returns a
marshaller that can construct an &lt;code&gt;HttpResponse&lt;/code&gt;. The method has the following
signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// From the ScalaDoc
implicit def fromStatusCodeAndHeadersAndValue[T](implicit mt: ToEntityMarshaller[T]): TRM[(StatusCode, Seq[HttpHeader], T)] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compose&lt;/code&gt; is used to ensure that the status code is included in the
response.&lt;/p&gt;

&lt;h2 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;Finally, let&amp;rsquo;s mix in the &lt;code&gt;ApiMarshalling&lt;/code&gt; trait.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Routes extends ApiMarshalling {
  def noteService: NoteService
  
  val notesRoute =
    pathPrefix(&amp;quot;notes&amp;quot;) {
      path(IntNumber) { id =&amp;gt;
        get {
          complete {
            noteService.find(id)
          }
        }
        // ...
      }
    }
    // Rest omitted because it&#39;s mostly the same
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the differnce between the original code and the code using the
marshaller:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ApiResult&lt;/code&gt; is automatically serialized, so we don&amp;rsquo;t have to call &lt;code&gt;write&lt;/code&gt;
anymore. Plus, Akka HTTP has implicit functions to derive
&lt;code&gt;ToResponseMarshaller[Future[A]]&lt;/code&gt; from a &lt;code&gt;ToResponseMarshaller[A]&lt;/code&gt;, so we can
just leave each call as a &lt;code&gt;Future[ApiResult]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The status code is correctly included in the response.&lt;/li&gt;
&lt;li&gt;The content type is &lt;code&gt;application/json&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When a new &lt;code&gt;ApiResult&lt;/code&gt; is added, the only status code or serialization logic
that needs to be implemented is a case in &lt;code&gt;getResponseCode&lt;/code&gt;. In addition, the
compiler will even issue a warning as a reminder!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While the example shown in this article is relatively simple, it&amp;rsquo;s easy to see
how marshallers can be used to reduce boilerplate and unify logic. They&amp;rsquo;re also
extensible: if you wanted to implement XML serialization, all you&amp;rsquo;d have to do
is create a &lt;code&gt;ToEntityMarshaller[ApiResult]&lt;/code&gt; for XML, refactor &lt;code&gt;apiResultTEM&lt;/code&gt; to
accept &lt;code&gt;apiResultTEM&lt;/code&gt; as a parameter, and pass the XML marshaller to
&lt;code&gt;apiResultTEM&lt;/code&gt;. One marshaller that I found very useful to have, in particular,
is a marshaller for a &lt;code&gt;Task&lt;/code&gt; monad. It makes libraries such as &lt;code&gt;fs2&lt;/code&gt; or &lt;code&gt;doobie&lt;/code&gt;
interop very well with Akka HTTP. Anyways, if you&amp;rsquo;d like to learn more about
marshallers, check out the &lt;a href=&#34;http://doc.akka.io/docs/akka-http/current/scala/http/common/marshalling.html&#34;&gt;documentation&lt;/a&gt;. There are many more
ways to use marshallers than I have presented in this article, such as streaming
or chunking responses.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>